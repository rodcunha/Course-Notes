# Service Workers

## Registering a service worker

To register a service worker we will need to use the navigator.serviceWorker method register and give it a path like so:

``` javascript
navigator.serviceWorker.register('sw.js');
```

This will register the servie worker with the browser and returns a promise, you will then get callbacks for success and failure.

You can also pass a scope as the second parameter of the register call like so:

``` javascript 
navigator.serviceWorker.register('sw.js', {
  scope: '/app/'
});
```
For this example the serve worker will control any files and sub directories of the scope but nothing above in the tree. Usually there's no need to set the scope, just place the sw file in the proper folder.

As of 2018 most browsers support service workers and there shouldn't be a problem implementing but I think it is still a good idea to check for browser support when implementing so here how we can do that: 

``` javascript 
if (navigator.serviceWorker) {
  navigator.serviceWorker.register('sw.js');
}
```

If the browser doesn't support service workers the navigator.serviceWorker value will be `undefined` which is a falsy value and the browser will skip everything contained in the if statement.

## Event Listeners

The service worker receives events and therefore we can add `eventListeners` to the service worker in order to complete certain tasks. 

### Fetch Event Listener

When the user navigates to a page within the service worker's scope, it controlls the page's actions. The network's request for the HTML goes to the service worker and triggers a `fetch` event. But that doesn't happen only for the HTML, a `fetch` event is triggered for every request sent by that page (Ie. images, css, js, etc).

Adding the fetch event listener to the service worker:

``` javascript
  self.addEventListener('fetch', function(event) {
    // do something
  });
```
self here refers to the service worker object. Once a `fetch` event is triggered we can access that returned data and interact with it.


## Service Worker Lifecycle

After registering a service worker the first browser refresh will fetch the service worker, however even though the new js with the registration of the service worker was read and the service worker is a part of the document it isn't yet active and therefore all requests made by the page will bypass the service worker. Only when the browser is refreshed a second time will the service worker start intercepting network requeeventsts. 

If a change is made to the service worker, the next request will trigger a new version of the service worker, this will not be active until ALL windows running the previous version have exited. Refreshing the page will not help here as there is an overlap and the window isn't exactly active, you will need to navigate out of the webpage so that the new version of the service worker will take over. This happens so that the website displays a consistent version to every user accessing it. 

It is possible during development to setup the browser so that the service worker updates with each refresh, this can be done on the application tab of the developer tools in chrome. 

## Hijacking Requests

An important part of an offline first experience is to intercept the fetch requests generated by the browser before they reach the network layer. To do that we will need to "hijack" the request and respond to it through the service worker. In order to achieve that we can: 

``` javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('this is my response')
  );
}
```

`event.respondWith` takes a `Response` object or a promise that resolves with a response.
The `new Response` can take a second parameter where you can pass an object of keys and values, for instance you can pass headers to the page as such, enabling us to pass HTML markup as part of the Response string:

``` javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('this is my <b>response</b>', {
      headers: {
        'content-type': 'text/html'
        }
    )
  );
}
```

## Triggering an Update

[Documentation on `self.skipWaiting();`](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase "Google Documentataion")
