# Service Workers

## Contents

1. Useful Links & Materials
2. Registering a Service Worker
3. Event Listeners
4. Service Workers Lifecycle
5. Hijacking Requests
6. Caching and Serving Assets


## 1. Useful Links & Materials

[Google Course on Progressive Web Apps - Youtube](https://www.youtube.com/playlist?list=PLNYkxOF6rcIAdnzEsWkg0KpMn2WJwMBmN)
[Google PWA Course - Google Developers](https://developers.google.com/web/ilt/pwa/)


## 2. Registering a service worker

To register a service worker we will need to use the navigator.serviceWorker method register and give it a path like so:

``` javascript
navigator.serviceWorker.register('sw.js');
```

This will register the servie worker with the browser and returns a promise, you will then get callbacks for success and failure.

You can also pass a scope as the second parameter of the register call like so:

``` javascript 
navigator.serviceWorker.register('sw.js', {
  scope: '/app/'
});
```
For this example the serve worker will control any files and sub directories of the scope but nothing above in the tree. Usually there's no need to set the scope, just place the sw file in the proper folder.

As of 2018 most browsers support service workers and there shouldn't be a problem implementing but I think it is still a good idea to check for browser support when implementing so here how we can do that: 

``` javascript 
if (navigator.serviceWorker) {
  navigator.serviceWorker.register('sw.js');
}
```

If the browser doesn't support service workers the navigator.serviceWorker value will be `undefined` which is a falsy value and the browser will skip everything contained in the if statement.

## 3. Event Listeners

The service worker receives events and therefore we can add `eventListeners` to the service worker in order to complete certain tasks. 

### Fetch Event Listener

When the user navigates to a page within the service worker's scope, it controlls the page's actions. The network's request for the HTML goes to the service worker and triggers a `fetch` event. But that doesn't happen only for the HTML, a `fetch` event is triggered for every request sent by that page (Ie. images, css, js, etc).

Adding the fetch event listener to the service worker:

``` javascript
  self.addEventListener('fetch', function(event) {
    // do something
  });
```
self here refers to the service worker object. Once a `fetch` event is triggered we can access that returned data and interact with it.


## 4. Service Worker Lifecycle

After registering a service worker the first browser refresh will fetch the service worker, however even though the new js with the registration of the service worker was read and the service worker is a part of the document it isn't yet active and therefore all requests made by the page will bypass the service worker. Only when the browser is refreshed a second time will the service worker start intercepting network requeeventsts. 

If a change is made to the service worker, the next request will trigger a new version of the service worker, this will not be active until ALL windows running the previous version have exited. Refreshing the page will not help here as there is an overlap and the window isn't exactly active, you will need to navigate out of the webpage so that the new version of the service worker will take over. This happens so that the website displays a consistent version to every user accessing it. 

It is possible during development to setup the browser so that the service worker updates with each refresh, this can be done on the application tab of the developer tools in chrome. 

## 5. Hijacking Requests

An important part of an offline first experience is to intercept the fetch requests generated by the browser before they reach the network layer. To do that we will need to "hijack" the request and respond to it through the service worker. In order to achieve that we can: 

``` javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('this is my response')
  );
}
```

`event.respondWith` takes a `Response` object or a promise that resolves with a response.
The `new Response` can take a second parameter where you can pass an object of keys and values, for instance you can pass headers to the page as such, enabling us to pass HTML markup as part of the Response string:

``` javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    new Response('this is my <b>response</b>', {
      headers: {
        'content-type': 'text/html'
        }
    )
  );
}
```
We can also respond with a promise that resolves as a response as such:

``` javascript
self.addEventListener('fetch', function(event) {
  event.respondWith(
    fetch('https://www.someurl.com/myImage.jpg')
      .then( () => {
        //do something
      })
      .catch( err => {
        //do something
      })
  );
}
```

## Caching and Serving Assets

[The Cache API - MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Cache)

The Cache API gives us the global caches object. 

### To Create or Open a New Cache
`caches.open('name-of-cache').then(function(cache) { //do something })`

`caches.open` returns a promise for a cache of that name, if this cache hasn't been opened before, it creates it and then returns the promise.

The cache "box" contains request/response pairs from any secure origin. It can be used to store almost anything (Ie. fonts, scripts, images, etc) from both our origin (server) as well as elsewhere on the web (we can cache remote resources like google fonts for instance).

### Adding to the Cache

We can add resources to the cache by using: 

`cache.put(request, response);`

or 

```javascript
cache.addAll([
  '/',
  'locationOne/',
  'locationTwo/'
])
```

`cache.addAll([])` takes an array of requests or URL's of resources to be added to the cache.
 
Note: If any of the requests in `cache.addAll` fails to cache none of them will be added, the whole request fails. This method uses `fetch` under the hood, so the requests will go via the browser cache.

### Retrieve from the Cache

In order to retrieve something from the cache, we can call: 

``` javascript
  cache.match('request');
```
We should pass in a request or a URL. This will return a promise for a matching response if one is found or return null otherwise.

`caches.match('request');` does the same, however it tries to find a match in any cache, starting with the oldest.

### When should we use the cache?

Usually the cache is initialized during the install event of the service worker. When the service worker is registered it triggers an install event and we can listen to that event and react to it. 

```javascript
  self.addEventListener('install', event => {
    event.waitUntil(
      //promise
    );
  });
```

`event.waitUntil` lets us signal the progress of the intall. We pass it a promise, if and when the promise resolves, the browser knows the install is complete, if the promise rejects, it knows the install has failed.

### Updating a Static Cache

to do


## Triggering an Update

[Documentation on `self.skipWaiting();`](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase "Google Documentataion")
